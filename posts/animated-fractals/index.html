<!doctype html><html lang=en-us dir=ltr><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="ie=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><title>Animate Your Own Fractals in Python with Matplotlib &#183; Matplotblog</title><meta name=description content="Discover the bizarre geometry of the fractals and learn how to make an animated visualization of these marvels using Python and the Matplotlib's Animation API."><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.1/normalize.min.css><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.10.0/dist/katex.min.css integrity=sha384-9eLZqc9ds8eNjO3TmqPeYcDj8n+Qfa4nuSiGYa6DjLNcv9BtN69ZIulL9+8CqC9Y crossorigin=anonymous><link href=https://matplotlib.org/matplotblog/css/concated.min.css rel=stylesheet><style>body{background:#ecedef url(https://matplotlib.org/matplotblog/bg_tiles.png)repeat}</style></head><body class=single-body><nav class="nav-bar side-padding"><h1 class=nav-header><a href=https://matplotlib.org/matplotblog/ class=nav-text><img src=https://matplotlib.org/matplotblog/mpl_logo.png></a></h1><a href=https://matplotlib.org/matplotblog/index.xml><img src=https://matplotlib.org/matplotblog/rss.svg style=width:25px;margin:10px alt="RSS feed"></a><div class=hamburger-menu><button onclick=hamburgerMenuPressed.call(this) aria-haspopup=true aria-expanded=false aria-controls=menu aria-label=Menu>
<span></span><span></span></button><ul id=menu class=hamburger-menu-overlay><li><a href=https://matplotlib.org/matplotblog/ class=hamburger-menu-overlay-link>Home</a></li><li><a href=https://matplotlib.org/matplotblog/posts/how-to-contribute/ class=hamburger-menu-overlay-link>How to Contribute</a></li><li><a href=https://matplotlib.org/matplotblog/categories/3d class=hamburger-menu-overlay-link>3d</a></li><li><a href=https://matplotlib.org/matplotblog/categories/academia class=hamburger-menu-overlay-link>Academia</a></li><li><a href=https://matplotlib.org/matplotblog/categories/art class=hamburger-menu-overlay-link>Art</a></li><li><a href=https://matplotlib.org/matplotblog/categories/editorial class=hamburger-menu-overlay-link>Editorial</a></li><li><a href=https://matplotlib.org/matplotblog/categories/graphs class=hamburger-menu-overlay-link>Graphs</a></li><li><a href=https://matplotlib.org/matplotblog/categories/gsoc class=hamburger-menu-overlay-link>Gsoc</a></li><li><a href=https://matplotlib.org/matplotblog/categories/industry class=hamburger-menu-overlay-link>Industry</a></li><li><a href=https://matplotlib.org/matplotblog/categories/news class=hamburger-menu-overlay-link>News</a></li><li><a href=https://matplotlib.org/matplotblog/categories/tutorials class=hamburger-menu-overlay-link>Tutorials</a></li><li><a href=https://matplotlib.org class=hamburger-menu-overlay-link target=blank>About</a></li></ul></div></nav><main class="content side-text-padding"><article class="post dropcase"><header class=post-header><h1 class=post-title>Animate Your Own Fractals in Python with Matplotlib</h1><p class=post-date>Posted <time datetime=2020-07-04>Jul 4, 2020</time>
<span class=post-author>&mdash; By Vladimir Ilievski</span></p></header><picture class=post-figure>
<source srcset=https://matplotlib.org/matplotblog/posts/animated-fractals/header_image_huf8e570c04f7e2dc218d301e5344d7752_272123_800x0_resize_lanczos_2.png><img src=https://matplotlib.org/matplotblog/posts/animated-fractals/header_image_huf8e570c04f7e2dc218d301e5344d7752_272123_800x0_resize_lanczos_2.png alt="Julia Set Fractal"></picture><p>Imagine zooming an image over and over and never go out of finer details. It may sound bizarre but the mathematical
concept of <a href=https://en.wikipedia.org/wiki/Fractal>fractals</a> opens the realm towards this intricating infinity. This
strange geometry exhibits the same or similar patterns irrespectively of the scale. We can see one fractal example
in the image above.</p><p>The <em>fractals</em> may seem difficult to understand due to their peculiarity, but that's not the case. As Benoit Mandelbrot,
one of the founding fathers of the fractal geometry said in his legendary
<a href="https://www.ted.com/talks/benoit_mandelbrot_fractals_and_the_art_of_roughness?language=en">TED Talk</a>:</p><blockquote><p>A surprising aspect is that the rules of this geometry are extremely short. You crank the formulas several times and
at the end, you get things like this (pointing to a stunning plot)</p><p>&ndash; Benoit Mandelbrot</p></blockquote><p>In this tutorial blog post, we will see how to construct fractals in Python and animate them using the amazing
<em>Matplotlib's</em> Animation API. First, we will demonstrate the convergence of the <em>Mandelbrot Set</em> with an
enticing animation. In the second part, we will analyze one interesting property of the <em>Julia Set</em>. Stay tuned!</p><h1 id=intuition>Intuition</h1><p>We all have a common sense of the concept of similarity. We say two objects are similar to each other if they share
some common patterns.</p><p>This notion is not only limited to a comparison of two different objects. We can also compare different parts of the
same object. For instance, a leaf. We know very well that the left side matches exactly the right side, i.e. the leaf
is symmetrical.</p><p>In mathematics, this phenomenon is known as <a href=https://en.wikipedia.org/wiki/Self-similarity>self-similarity</a>. It means
a given object is similar (completely or to some extent) to some smaller part of itself. One remarkable example is the
<a href=https://isquared.digital/visualizations/2020-06-15-koch-curve/>Koch Snowflake</a> as shown in the image below:</p><p><img src=snowflake.png alt="Koch Snowflake"></p><p>We can infinitely magnify some part of it and the same pattern will repeat over and over again. This is how fractal
geometry is defined.</p><h1 id=animated-mandelbrot-set>Animated Mandelbrot Set</h1><p><a href=https://en.wikipedia.org/wiki/Mandelbrot_set>Mandelbrot Set</a> is defined over the set of <em>complex numbers</em>. It consists
of all complex numbers <strong>c</strong>, such that the sequence <strong>zᵢ₊ᵢ = zᵢ² + c, z₀ = 0</strong> is bounded. It means, after a certain
number of iterations the absolute value must not exceed a given limit. At first sight, it might
seem odd and simple, but in fact, it has some mind-blowing properties.</p><p>The <em>Python</em> implementation is quite straightforward, as given in the code snippet below:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>mandelbrot</span>(x, y, threshold):
    <span style=color:#e6db74></span><span style=color:#e6db74>&#34;&#34;&#34;</span><span style=color:#e6db74>Calculates whether the number c = x + i*y belongs to the </span><span style=color:#e6db74>
</span><span style=color:#e6db74></span><span style=color:#e6db74>    Mandelbrot set. In order to belong, the sequence z[i + 1] = z[i]**2 + c</span><span style=color:#e6db74>
</span><span style=color:#e6db74></span><span style=color:#e6db74>    must not diverge after </span><span style=color:#e6db74>&#39;</span><span style=color:#e6db74>threshold</span><span style=color:#e6db74>&#39;</span><span style=color:#e6db74> number of steps. The sequence diverges</span><span style=color:#e6db74>
</span><span style=color:#e6db74></span><span style=color:#e6db74>    if the absolute value of z[i+1] is greater than 4.</span><span style=color:#e6db74>
</span><span style=color:#e6db74></span><span style=color:#e6db74>    </span><span style=color:#e6db74>
</span><span style=color:#e6db74></span><span style=color:#e6db74>    :param float x: the x component of the initial complex number</span><span style=color:#e6db74>
</span><span style=color:#e6db74></span><span style=color:#e6db74>    :param float y: the y component of the initial complex number</span><span style=color:#e6db74>
</span><span style=color:#e6db74></span><span style=color:#e6db74>    :param int threshold: the number of iterations to considered it converged</span><span style=color:#e6db74>
</span><span style=color:#e6db74></span><span style=color:#e6db74>    </span><span style=color:#e6db74>&#34;&#34;&#34;</span>
    <span style=color:#75715e># initial conditions</span>
    c <span style=color:#f92672>=</span> complex(x, y)
    z <span style=color:#f92672>=</span> complex(<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>)
    
    <span style=color:#66d9ef>for</span> i <span style=color:#f92672>in</span> range(threshold):
        z <span style=color:#f92672>=</span> z<span style=color:#f92672>*</span><span style=color:#f92672>*</span><span style=color:#ae81ff>2</span> <span style=color:#f92672>+</span> c
        <span style=color:#66d9ef>if</span> abs(z) <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>4.</span>:  <span style=color:#75715e># it diverged</span>
            <span style=color:#66d9ef>return</span> i
        
    <span style=color:#66d9ef>return</span> threshold <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>  <span style=color:#75715e># it didn&#39;t diverge</span>
</code></pre></div><p>As we can see, we set the maximum number of iterations encoded in the variable <code>threshold</code>. If the magnitude of the
sequence at some iteration exceeds <strong>4</strong>, we consider it as diverged (<strong>c</strong> does not belong to the set) and return the
iteration number at which this occurred. If this never happens (<strong>c</strong> belongs to the set), we return the maximum
number of iterations.</p><p>We can use the information about the number of iterations before the sequence diverges. All we have to do
is to associate this number to a color relative to the maximum number of loops. Thus, for all complex numbers
<strong>c</strong> in some lattice of the complex plane, we can make a nice animation of the convergence process as a function
of the maximum allowed iterations.</p><p>One particular and interesting area is the <em>3x3</em> lattice starting at position -2 and -1.5 for the <em>real</em> and
<em>imaginary</em> axis respectively. We can observe the process of convergence as the number of allowed iterations increases.
This is easily achieved using the <em>Matplotlib's</em> Animation API, as shown with the following code:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#f92672>import</span> numpy <span style=color:#f92672>as</span> np
<span style=color:#f92672>import</span> matplotlib.pyplot <span style=color:#f92672>as</span> plt
<span style=color:#f92672>import</span> matplotlib.animation <span style=color:#f92672>as</span> animation

x_start, y_start <span style=color:#f92672>=</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>2</span>, <span style=color:#f92672>-</span><span style=color:#ae81ff>1.5</span>  <span style=color:#75715e># an interesting region starts here</span>
width, height <span style=color:#f92672>=</span> <span style=color:#ae81ff>3</span>, <span style=color:#ae81ff>3</span>  <span style=color:#75715e># for 3 units up and right</span>
density_per_unit <span style=color:#f92672>=</span> <span style=color:#ae81ff>250</span>  <span style=color:#75715e># how many pixles per unit</span>

<span style=color:#75715e># real and imaginary axis</span>
re <span style=color:#f92672>=</span> np<span style=color:#f92672>.</span>linspace(x_start, x_start <span style=color:#f92672>+</span> width, width <span style=color:#f92672>*</span> density_per_unit )
im <span style=color:#f92672>=</span> np<span style=color:#f92672>.</span>linspace(y_start, y_start <span style=color:#f92672>+</span> height, height <span style=color:#f92672>*</span> density_per_unit)

fig <span style=color:#f92672>=</span> plt<span style=color:#f92672>.</span>figure(figsize<span style=color:#f92672>=</span>(<span style=color:#ae81ff>10</span>, <span style=color:#ae81ff>10</span>))  <span style=color:#75715e># instantiate a figure to draw</span>
ax <span style=color:#f92672>=</span> plt<span style=color:#f92672>.</span>axes()  <span style=color:#75715e># create an axes object</span>

<span style=color:#66d9ef>def</span> <span style=color:#a6e22e>animate</span>(i):
    ax<span style=color:#f92672>.</span>clear()  <span style=color:#75715e># clear axes object</span>
    ax<span style=color:#f92672>.</span>set_xticks([], [])  <span style=color:#75715e># clear x-axis ticks</span>
    ax<span style=color:#f92672>.</span>set_yticks([], [])  <span style=color:#75715e># clear y-axis ticks</span>
    
    X <span style=color:#f92672>=</span> np<span style=color:#f92672>.</span>empty((len(re), len(im)))  <span style=color:#75715e># re-initialize the array-like image</span>
    threshold <span style=color:#f92672>=</span> round(<span style=color:#ae81ff>1.15</span><span style=color:#f92672>*</span><span style=color:#f92672>*</span>(i <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>))  <span style=color:#75715e># calculate the current threshold</span>
    
    <span style=color:#75715e># iterations for the current threshold</span>
    <span style=color:#66d9ef>for</span> i <span style=color:#f92672>in</span> range(len(re)):
        <span style=color:#66d9ef>for</span> j <span style=color:#f92672>in</span> range(len(im)):
            X[i, j] <span style=color:#f92672>=</span> mandelbrot(re[i], im[j], threshold)
    
    <span style=color:#75715e># associate colors to the iterations with an iterpolation</span>
    img <span style=color:#f92672>=</span> ax<span style=color:#f92672>.</span>imshow(X<span style=color:#f92672>.</span>T, interpolation<span style=color:#f92672>=</span><span style=color:#e6db74></span><span style=color:#e6db74>&#34;</span><span style=color:#e6db74>bicubic</span><span style=color:#e6db74>&#34;</span>, cmap<span style=color:#f92672>=</span><span style=color:#e6db74></span><span style=color:#e6db74>&#39;</span><span style=color:#e6db74>magma</span><span style=color:#e6db74>&#39;</span>)
    <span style=color:#66d9ef>return</span> [img]
 
anim <span style=color:#f92672>=</span> animation<span style=color:#f92672>.</span>FuncAnimation(fig, animate, frames<span style=color:#f92672>=</span><span style=color:#ae81ff>45</span>, interval<span style=color:#f92672>=</span><span style=color:#ae81ff>120</span>, blit<span style=color:#f92672>=</span>True)
anim<span style=color:#f92672>.</span>save(<span style=color:#e6db74></span><span style=color:#e6db74>&#39;</span><span style=color:#e6db74>mandelbrot.gif</span><span style=color:#e6db74>&#39;</span>,writer<span style=color:#f92672>=</span><span style=color:#e6db74></span><span style=color:#e6db74>&#39;</span><span style=color:#e6db74>imagemagick</span><span style=color:#e6db74>&#39;</span>)
</code></pre></div><p>We make animations in <em>Matplotlib</em> using the <code>FuncAnimation</code> function from the <em>Animation</em> API. We need to specify
the <code>figure</code> on which we draw a predefined number of consecutive <code>frames</code>. A predetermined <code>interval</code> expressed in
milliseconds defines the delay between the frames.</p><p>In this context, the <code>animate</code> function plays a central role, where the input argument is the frame number, starting
from 0. It means, in order to animate we always have to think in terms of frames. Hence, we use the frame number
to calculate the variable <code>threshold</code> which is the maximum number of allowed iterations.</p><p>To represent our lattice we instantiate two arrays <code>re</code> and <code>im</code>: the former for the values on the <em>real</em> axis
and the latter for the values on the <em>imaginary</em> axis. The number of elements in these two arrays is defined by
the variable <code>density_per_unit</code> which defines the number of samples per unit step. The higher it is, the better
quality we get, but at a cost of heavier computation.</p><p>Now, depending on the current <code>threshold</code>, for every complex number <strong>c</strong> in our lattice, we calculate the number of
iterations before the sequence <strong>zᵢ₊ᵢ = zᵢ² + c, z₀ = 0</strong> diverges. We save them in an initially empty matrix called <code>X</code>.
In the end, we <em>interpolate</em> the values in <code>X</code> and assign them a color drawn from a prearranged <em>colormap</em>.</p><p>After cranking the <code>animate</code> function multiple times we get a stunning animation as depicted below:</p><p><img src=mandelbrot.gif alt="Mandelbrot set animation"></p><h1 id=animated-julia-set>Animated Julia Set</h1><p>The <a href=https://en.wikipedia.org/wiki/Julia_set>Julia Set</a> is quite similar to the <em>Mandelbrot Set</em>. Instead of setting
<strong>z₀ = 0</strong> and testing whether for some complex number <strong>c = x + i*y</strong> the sequence <strong>zᵢ₊ᵢ = zᵢ² + c</strong> is bounded, we
switch the roles a bit. We fix the value for <strong>c</strong>, we set an arbitrary initial condition <strong>z₀ = x + i*y</strong>, and we
observe the convergence of the sequence. The <em>Python</em> implementation is given below:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>julia_quadratic</span>(zx, zy, cx, cy, threshold):
    <span style=color:#e6db74></span><span style=color:#e6db74>&#34;&#34;&#34;</span><span style=color:#e6db74>Calculates whether the number z[0] = zx + i*zy with a constant c = x + i*y</span><span style=color:#e6db74>
</span><span style=color:#e6db74></span><span style=color:#e6db74>    belongs to the Julia set. In order to belong, the sequence </span><span style=color:#e6db74>
</span><span style=color:#e6db74></span><span style=color:#e6db74>    z[i + 1] = z[i]**2 + c, must not diverge after </span><span style=color:#e6db74>&#39;</span><span style=color:#e6db74>threshold</span><span style=color:#e6db74>&#39;</span><span style=color:#e6db74> number of steps.</span><span style=color:#e6db74>
</span><span style=color:#e6db74></span><span style=color:#e6db74>    The sequence diverges if the absolute value of z[i+1] is greater than 4.</span><span style=color:#e6db74>
</span><span style=color:#e6db74></span><span style=color:#e6db74>    </span><span style=color:#e6db74>
</span><span style=color:#e6db74></span><span style=color:#e6db74>    :param float zx: the x component of z[0]</span><span style=color:#e6db74>
</span><span style=color:#e6db74></span><span style=color:#e6db74>    :param float zy: the y component of z[0]</span><span style=color:#e6db74>
</span><span style=color:#e6db74></span><span style=color:#e6db74>    :param float cx: the x component of the constant c</span><span style=color:#e6db74>
</span><span style=color:#e6db74></span><span style=color:#e6db74>    :param float cy: the y component of the constant c</span><span style=color:#e6db74>
</span><span style=color:#e6db74></span><span style=color:#e6db74>    :param int threshold: the number of iterations to considered it converged</span><span style=color:#e6db74>
</span><span style=color:#e6db74></span><span style=color:#e6db74>    </span><span style=color:#e6db74>&#34;&#34;&#34;</span>
    <span style=color:#75715e># initial conditions</span>
    z <span style=color:#f92672>=</span> complex(zx, zy)
    c <span style=color:#f92672>=</span> complex(cx, cy)
    
    <span style=color:#66d9ef>for</span> i <span style=color:#f92672>in</span> range(threshold):
        z <span style=color:#f92672>=</span> z<span style=color:#f92672>*</span><span style=color:#f92672>*</span><span style=color:#ae81ff>2</span> <span style=color:#f92672>+</span> c
        <span style=color:#66d9ef>if</span> abs(z) <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>4.</span>:  <span style=color:#75715e># it diverged</span>
            <span style=color:#66d9ef>return</span> i
        
    <span style=color:#66d9ef>return</span> threshold <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>  <span style=color:#75715e># it didn&#39;t diverge</span>
</code></pre></div><p>Obviously, the setup is quite similar as the <em>Mandelbrot Set</em> implementation. The maximum number of iterations is
denoted as <code>threshold</code>. If the magnitude of the sequence is never greater than <strong>4</strong>, the number <strong>z₀</strong> belongs to
the <em>Julia Set</em> and vice-versa.</p><p>The number <strong>c</strong> is giving us the freedom to analyze its impact on the convergence of the sequence, given that the
number of maximum iterations is fixed. One interesting range of values for <strong>c</strong> is for <strong>c = r cos α + i × r sin α</strong>
such that <strong>r=0.7885</strong> and <strong>α ∈ [0, 2π]</strong>.</p><p>The best possible way to make this analysis is to create an animated visualization as the number <strong>c</strong> changes.
This <a href=https://isquared.digital/blog/2020-02-08-interactive-dataviz/>ameliorates our visual perception</a> and
understanding of such abstract phenomena in a captivating manner. To do so, we use the Matplotlib's <em>Animation API</em>, as
demonstrated in the code below:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#f92672>import</span> numpy <span style=color:#f92672>as</span> np
<span style=color:#f92672>import</span> matplotlib.pyplot <span style=color:#f92672>as</span> plt
<span style=color:#f92672>import</span> matplotlib.animation <span style=color:#f92672>as</span> animation

x_start, y_start <span style=color:#f92672>=</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>2</span>, <span style=color:#f92672>-</span><span style=color:#ae81ff>2</span>  <span style=color:#75715e># an interesting region starts here</span>
width, height <span style=color:#f92672>=</span> <span style=color:#ae81ff>4</span>, <span style=color:#ae81ff>4</span>  <span style=color:#75715e># for 4 units up and right</span>
density_per_unit <span style=color:#f92672>=</span> <span style=color:#ae81ff>200</span>  <span style=color:#75715e># how many pixles per unit</span>

<span style=color:#75715e># real and imaginary axis</span>
re <span style=color:#f92672>=</span> np<span style=color:#f92672>.</span>linspace(x_start, x_start <span style=color:#f92672>+</span> width, width <span style=color:#f92672>*</span> density_per_unit )
im <span style=color:#f92672>=</span> np<span style=color:#f92672>.</span>linspace(y_start, y_start <span style=color:#f92672>+</span> height, height <span style=color:#f92672>*</span> density_per_unit)


threshold <span style=color:#f92672>=</span> <span style=color:#ae81ff>20</span>  <span style=color:#75715e># max allowed iterations</span>
frames <span style=color:#f92672>=</span> <span style=color:#ae81ff>100</span>  <span style=color:#75715e># number of frames in the animation</span>

<span style=color:#75715e># we represent c as c = r*cos(a) + i*r*sin(a) = r*e^{i*a}</span>
r <span style=color:#f92672>=</span> <span style=color:#ae81ff>0.7885</span>
a <span style=color:#f92672>=</span> np<span style=color:#f92672>.</span>linspace(<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>2</span><span style=color:#f92672>*</span>np<span style=color:#f92672>.</span>pi, frames)

fig <span style=color:#f92672>=</span> plt<span style=color:#f92672>.</span>figure(figsize<span style=color:#f92672>=</span>(<span style=color:#ae81ff>10</span>, <span style=color:#ae81ff>10</span>))  <span style=color:#75715e># instantiate a figure to draw</span>
ax <span style=color:#f92672>=</span> plt<span style=color:#f92672>.</span>axes()  <span style=color:#75715e># create an axes object</span>

<span style=color:#66d9ef>def</span> <span style=color:#a6e22e>animate</span>(i):
    ax<span style=color:#f92672>.</span>clear()  <span style=color:#75715e># clear axes object</span>
    ax<span style=color:#f92672>.</span>set_xticks([], [])  <span style=color:#75715e># clear x-axis ticks</span>
    ax<span style=color:#f92672>.</span>set_yticks([], [])  <span style=color:#75715e># clear y-axis ticks</span>
    
    X <span style=color:#f92672>=</span> np<span style=color:#f92672>.</span>empty((len(re), len(im)))  <span style=color:#75715e># the initial array-like image</span>
    cx, cy <span style=color:#f92672>=</span> r <span style=color:#f92672>*</span> np<span style=color:#f92672>.</span>cos(a[i]), r <span style=color:#f92672>*</span> np<span style=color:#f92672>.</span>sin(a[i])  <span style=color:#75715e># the initial c number</span>
    
    <span style=color:#75715e># iterations for the given threshold</span>
    <span style=color:#66d9ef>for</span> i <span style=color:#f92672>in</span> range(len(re)):
        <span style=color:#66d9ef>for</span> j <span style=color:#f92672>in</span> range(len(im)):
            X[i, j] <span style=color:#f92672>=</span> julia_quadratic(re[i], im[j], cx, cy, threshold)
    
    img <span style=color:#f92672>=</span> ax<span style=color:#f92672>.</span>imshow(X<span style=color:#f92672>.</span>T, interpolation<span style=color:#f92672>=</span><span style=color:#e6db74></span><span style=color:#e6db74>&#34;</span><span style=color:#e6db74>bicubic</span><span style=color:#e6db74>&#34;</span>, cmap<span style=color:#f92672>=</span><span style=color:#e6db74></span><span style=color:#e6db74>&#39;</span><span style=color:#e6db74>magma</span><span style=color:#e6db74>&#39;</span>)
    <span style=color:#66d9ef>return</span> [img]

anim <span style=color:#f92672>=</span> animation<span style=color:#f92672>.</span>FuncAnimation(fig, animate, frames<span style=color:#f92672>=</span>frames, interval<span style=color:#f92672>=</span><span style=color:#ae81ff>50</span>, blit<span style=color:#f92672>=</span>True)
anim<span style=color:#f92672>.</span>save(<span style=color:#e6db74></span><span style=color:#e6db74>&#39;</span><span style=color:#e6db74>julia_set.gif</span><span style=color:#e6db74>&#39;</span>, writer<span style=color:#f92672>=</span><span style=color:#e6db74></span><span style=color:#e6db74>&#39;</span><span style=color:#e6db74>imagemagick</span><span style=color:#e6db74>&#39;</span>)
</code></pre></div><p>The logic in the <code>animate</code> function is very similar to the previous example. We update the number <strong>c</strong> as a function
of the frame number. Based on that we estimate the convergence of all complex numbers in the defined lattice, given the
fixed <code>threshold</code> of allowed iterations. Same as before, we save the results in an initially empty matrix <code>X</code> and
associate them to a color relative to the maximum number of iterations. The resulting animation is illustrated below:</p><p><img src=julia_set.gif alt="Julia Set Animation"></p><h1 id=summary>Summary</h1><p>The fractals are really mind-gobbling structures as we saw during this blog. First, we gave a general intuition
of the fractal geometry. Then, we observed two types of fractals: the <em>Mandelbrot</em> and <em>Julia</em> sets. We implemented
them in Python and made interesting animated visualizations of their properties.</p></article></main><nav class="end-nav side-padding"></nav><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.13.1/highlight.min.js></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.10.0/dist/katex.min.js integrity=sha384-K3vbOmF2BtaVai+Qk37uypf7VrgBubhQreNQe9aGsz9lB63dIFiQVlJbr92dw2Lx crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.10.0/dist/contrib/auto-render.min.js integrity=sha384-kmZOZB5ObwgQnS/DuDg6TScgOiWWBiVt0plIRkZCmE6rDZGrEOQeHM5PcHi+nyqe crossorigin=anonymous onload=renderMathInElement(document.body);></script><script src=https://matplotlib.org/matplotblog/js/core.min.js></script><script>hljs.initHighlightingOnLoad();</script></body></html>